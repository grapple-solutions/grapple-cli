#!/bin/bash
set -e
. "$GRPL_WORKDIR/utils/help_menus"
. "$GRPL_WORKDIR/utils/checks"

cli_help() {
  grpl_resource_deploy_cli_help
  exit 0
}

[ "$1" = "help" ] || [ "$1" = "h" ] && cli_help

install_prerequisite

NS=grpl-system
DB_FILE_NS=grpl-dbfile
DB_NS=grpl-db
awsregistry="p7h7z5g3"
tmp_file_dest="/tmp/temp_file"




# ----------------------- functions code ---------------------------

transform_model_input_to_yaml() {

    check_and_install_yq

    local Models=$1
    # Convert the JSON-like string to valid JSON by replacing single quotes with double quotes
    json_string="${Models//\'/\"}"

    # Initialize an array to store the models
    models_name=()
    # Split the input string by pipe symbol (|)
    IFS='|' read -ra models_data <<< "$json_string"


    # Iterate over each model data
    index=0
    for model_data in "${models_data[@]}"; do
        # Extract the model name and its properties
        IFS=':' read -r model_name properties <<< "$model_data"
        yq -i ".grapi.models[$index].name=\"$model_name\" | .grapi.models[$index].name style=\"double\"" $template_file_dest
        
        # Parse the properties JSON and format it as YAML
        yq eval ".grapi.models[$index].spec += $properties" -i $template_file_dest
        models_name+=("$model_name")
        ((index+=1))
    done

}

transform_datasources_input_to_yaml() {

    check_and_install_yq

    local ds=$1
    # Convert the JSON-like string to valid JSON by replacing single quotes with double quotes
    json_string="${ds//\'/\"}"

    # Split the input string by pipe symbol (|)
    IFS='|' read -ra data_sources <<< "$json_string"

    # Iterate over each model data
    index=0
    for data_source in "${data_sources[@]}"; do
        # Extract the model name and its properties
        IFS=':' read -r data_source_name properties <<< "$model_data"
        yq -i ".grapi.datasources[$index].name=\"$data_source_name\" | .grapi.datasources[$index].name style=\"double\"" $template_file_dest
        
        # Parse the properties JSON and format it as YAML
        yq eval ".grapi.datasources[$index].spec += $properties" -i $template_file_dest
        ((index+=1))
    done

}

transform_discoveries_input_to_yaml() {

    check_and_install_yq

    local dsq=$1
    # Convert the JSON-like string to valid JSON by replacing single quotes with double quotes
    json_string="${dsq//\'/\"}"

    # Split the input string by pipe symbol (|)
    IFS='|' read -ra discoveries <<< "$json_string"

    # Iterate over each model data
    index=0
    for discovery in "${discoveries[@]}"; do
        # Extract the model name and its properties
        IFS=':' read -r discovery_name properties <<< "$model_data"
        yq -i ".grapi.discoveries[$index].name=\"$data_source_name\" | .grapi.discoveries[$index].name style=\"double\"" $template_file_dest
        
        # Parse the properties JSON and format it as YAML
        yq eval ".grapi.discoveries[$index].spec += $properties" -i $template_file_dest
        ((index+=1))
    done

}


take_relation_input() {
   
    status_log $TYPE_INFO "Do you want to add a relationship?"
    local another_rule=$(gum choose "Yes" "No") || exit $?
    
    if [ "$another_rule" == "No" ]; then
        return 0
    fi
    
    local models=("$@")
    local models_len=${#models[@]}
    RELATIONS="  relations:"
    index=0


    while true; do

        local relation_type=$(gum choose --header "Please select the relation type" $BELONGS_TO $HAS_MANY $HAS_MANY_THROUGH $HAS_ONE $REFRENCES_MANY) || exit $?
        status_log $TYPE_DEFAULT  "relation model template: ${relation_type}"

        if [[ $models_len > 0 ]]; then 
            local source_model=$(gum choose --header "Please select source model" "${models[@]}") || exit $?
            status_log $TYPE_DEFAULT  "source model: ${source_model}"

            local target_model=$(gum choose --header "Please select target model" "${models[@]}") || exit $?
            status_log $TYPE_DEFAULT  "destination model: ${target_model}" 
        else
            local source_model=$(prompt_for_input_with_validation "Please enter source model: " "source model" "$non_empty_regex" "please enter a valid value") || exit $?
            status_log $TYPE_DEFAULT  "source model: ${source_model}"

            local target_model=$(prompt_for_input_with_validation "Please enter target model: " "target model" "$non_empty_regex" "please enter a valid value") || exit $?
            status_log $TYPE_DEFAULT  "destination model: ${target_model}"       
        fi


        local foreign_key=$(prompt_for_input_with_validation "Foreign key name to define on the source model: " "Please enter foreign key" "$non_empty_regex" "please select valid foreign key") || exit $?
        status_log $TYPE_DEFAULT  "foreign_key: ${foreign_key}"

        local relation_name=$(prompt_for_input_with_validation "Relation name: " "Please enter relation name" "$non_empty_regex" "please select valid relation name") || exit $?
        status_log $TYPE_DEFAULT  "relation_name: ${relation_name}"

        local register_inclusion_resolver=$(gum choose --header "Allow Customers queries to include data from related Employees instances?" "Yes" "No") || exit $?
        status_log $TYPE_DEFAULT  "register_inclusion_resolver: ${register_inclusion_resolver}"
        
        if [ "$register_inclusion_resolver" == "Yes" ]; then
            register_inclusion_resolver=true
        else
            register_inclusion_resolver=false
        fi

        yq -i ".grapi.relations[$index].name=\"$relation_name\" | .grapi.relations[$index].name style=\"double\"" $template_file_dest
        yq -i ".grapi.relations[$index].spec.relationName=\"$relation_name\" | .grapi.relations[$index].spec.relationName style=\"double\"" $template_file_dest
        yq -i ".grapi.relations[$index].spec.destinationModel=\"$target_model\" | .grapi.relations[$index].spec.destinationModel style=\"double\"" $template_file_dest
        yq -i ".grapi.relations[$index].spec.foreignKeyName=\"$foreign_key\" | .grapi.relations[$index].spec.foreignKeyName style=\"double\"" $template_file_dest
        yq -i ".grapi.relations[$index].spec.relationType=\"$relation_type\" | .grapi.relations[$index].spec.relationType style=\"double\"" $template_file_dest
        yq -i ".grapi.relations[$index].spec.registerInclusionResolver=$register_inclusion_resolver" $template_file_dest
        
        status_log $TYPE_INFO "Do you want to add another relationship?"
        local another_rule=$(gum choose "Yes" "No") || exit $?
        
        if [ "$another_rule" == "No" ]; then
            return 0
        fi

        ((index+=1))
    

    done
    
}

take_model_input() {
    
    MODELS=""
    models_name=()
    i=0
    while true; do

        local model_name=$(prompt_for_input_with_validation "Enter the model name: " "Please enter model name" "$non_empty_regex" "please enter valid model name") || exit $?
        status_log $TYPE_DEFAULT  "Enter the model name: ${model_name}"
        yq -i ".grapi.models[$i].name=\"$model_name\" | .grapi.models[$i].name style=\"double\"" $template_file_dest

        models_name+=("$model_name")

        local base_name=$(gum choose --header "Please select the model base class:" "Entity" "Model") || exit $?
        status_log $TYPE_DEFAULT  "Please select the model base class: ${base_name}"        
        yq -i ".grapi.models[$i].spec.base=\"$base_name\"" $template_file_dest

        id_selected=0
        while true; do

            status_log $TYPE_INFO "Let's add property to $model_name"
            status_log $TYPE_INFO "Enter an empty property name when done"

            local property_name=$(prompt_for_explicit_input_with_validation "Enter the property name: " "Please enter property name" ".*" "please enter valid property name") || exit $?
            status_log $TYPE_DEFAULT  "Enter the property name: ${property_name}"

            if [[ $property_name == "" ]]; then
                break
            fi

            local property_type=$(gum choose --header "Please select the property type" "string" "number" "boolean" "object" "array" "date" "buffer" "geopoint" "any") || exit $?
            status_log $TYPE_DEFAULT  "Enter the property type: ${property_type}"   
            yq -i ".grapi.models[$i].spec.properties.$property_name.type=\"$property_type\"" $template_file_dest

            if [ $id_selected == 0 ]; then

                is_id=$(prompt_for_input_with_validation "Is $property_name the ID property? " "(y/N)" "$non_empty_regex" "please select valid value") || exit $?
                status_log $TYPE_DEFAULT  "Is $property_name the ID property? ${is_id}"                
                if [[ $is_id == "y" || $is_id == "Y" ]]; then
                    
                    is_generated=$(prompt_for_input_with_validation "Is $property_name generated automatically? " "(y/N)" "$non_empty_regex" "please select valid value") || exit $?
                    status_log $TYPE_DEFAULT  "Is $property_name generated automatically? ${is_generated}" 
                    id_selected=1

                    yq -i ".grapi.models[$i].spec.properties.$property_name.id=true" $template_file_dest
                    yq -i ".grapi.models[$i].spec.properties.$property_name.required=true" $template_file_dest

                    if [[ $is_generated == "y" || $is_generated == "Y" ]]; then
                        yq -i ".grapi.models[$i].spec.properties.$property_name.generated=true" $template_file_dest
                    fi

                    continue
                fi
            fi

            local is_required=$(prompt_for_input_with_validation "Is it required? " "(y/N)" "$non_empty_regex" "please enter valid property name") || exit $?
            status_log $TYPE_DEFAULT  "Is it required? ${is_required}"
            if [[ $is_generated == "y" || $is_generated == "Y" ]]; then
                yq -i ".grapi.models[$i].spec.properties.$property_name.required=true" $template_file_dest
            fi

            if [[ $is_required != "y" && $is_required != "Y" ]]; then
                default_value=$(prompt_for_explicit_input_with_validation "Default value [leave blank for none]: " "enter default value" ".*" "please select valid value") || exit $?
                status_log $TYPE_DEFAULT  "Default value [leave blank for none]: ${default_value}" 
                yq -i ".grapi.models[$i].spec.properties.$property_name.defaultFn=\"$default_value\"" $template_file_dest
            fi

        done

        status_log $TYPE_INFO "Do you want to add another model?"
        local another_rule=$(gum choose "Yes" "No") || exit $?
        
        if [ "$another_rule" == "No" ]; then
            return 0
        fi

        ((i+=1))

    done
    
}

deploy_template() {


    cli_log "resource deploy BEGIN"
    status_log $TYPE_DEFAULT "resource deploy is in progress"

    if [ "$(kubectl config current-context)" = "minikube" ]; then
        echo "patching for minikube..."
        MINIKUBE_PATCH=" --set gras.ssl=false --set grapi.ssl=false --set gruim.ssl=false "
    else
        MINIKUBE_PATCH=""
    fi

    if ! gum spin --title "Deploying db-file-template" -- helm upgrade --install ${GRAS_NAME} oci://public.ecr.aws/${awsregistry}/gras-deploy  -n ${KUBE_NS} -f $template_file_dest ${MINIKUBE_PATCH}; then
        status_log $TYPE_ERROR "Failed to deploy db-file template, configs might be invalid"
        exit 1
    fi
    
    status_log $TYPE_INFO "wait for $GRAS_NAME to be ready" 
    CRD="gras" && echo "Wait for $CRD to be deployed:" && SECONDS=0 && TIMEOUT=60 && until kubectl get $CRD -n $KUBE_NS | awk '{print $3}' | grep -q True >/dev/null 2>&1 || [ $SECONDS -ge $TIMEOUT ]; do echo -n .; sleep 1; done && if [ $SECONDS -ge $TIMEOUT ]; then status_log $TYPE_ERROR "Timeout exceeded, $CRD not deployed after 1 minute"; exit 1; else echo "$CRD deployed"; fi
    status_log $TYPE_SUCCESS "$CRD deployed"
    status_log $TYPE_SUCCESS "grpl db-file template is deployed"

}

check_and_create_kubens() {

    if [[ "$KUBE_NS" != "" ]] && ! kubectl get namespace "$KUBE_NS" >/dev/null 2>&1; then
        status_log $TYPE_INFO "namespace $KUBE_NS doesn't exist, now creating"
        kubectl create namespace "$KUBE_NS"
    elif [[ "$KUBE_NS" == "" ]]; then
        status_log $TYPE_INFO "Do you want to select existing namespace or create new one?"
        local another_rule=$(gum choose "Select from existing" "Create new") || exit $?
        
        if [ "$another_rule" == "Select from existing" ]; then
            namespaces=$(kubectl get namespaces -o name | awk -F'/' '{print $2}')
            current_ns="default"
            KUBE_NS=$(if [ "${KUBE_NS}" != "" ]; then echo ${KUBE_NS}; else gum choose  --header "Please select kubectl namespace you want to use, default value is '$current_ns'" $namespaces --selected=$current_ns ; fi) || exit $?
        else
            KUBE_NS=$(if [ "${KUBE_NS}" != "" ]; then echo ${KUBE_NS}; else prompt_for_input_with_validation "Enter KUBE_NS: " "Provide kube ns" "$non_empty_regex" "kube ns can't be empty"; fi) || exit $?
            if ! kubectl get namespace "$KUBE_NS" >/dev/null 2>&1; then
                    status_log $TYPE_INFO "namespace $KUBE_NS doesn't exist, now creating"
                    kubectl create namespace "$KUBE_NS"
            fi
        fi    
    fi
}

input_guim_option(){

    status_log $TYPE_DEFAULT "Do you want enable gruim?"
    ENABLE_GRUIM=$(if [ "${ENABLE_GRUIM}" != "" ]; then echo ${ENABLE_GRUIM}; else  gum choose "Yes" "No"; fi) || exit $?
    status_log $TYPE_DEFAULT "ENABLE_GRUIM: ${ENABLE_GRUIM}"
    
    if [ "$ENABLE_GRUIM" == "No" ]; then
        yq eval 'del(.gruims)' -i $template_file_dest
    fi

}

take_db_file_path() {
    DB_FILE_PATH=$(if [ "${DB_FILE_PATH}" != "" ]; then echo ${DB_FILE_PATH}; else prompt_for_explicit_input_with_validation "Enter DB_FILE_PATH: " "Provide file path where you want to store data, default value is $db_file_default_value" "$abs_path_regex" "please provide correct absolute file path"; fi) || exit $?
    if [ "${DB_FILE_PATH}" == "" ]; then 
        DB_FILE_PATH=$db_file_default_value
    fi
    status_log $TYPE_DEFAULT "DB_FILE_PATH: ${DB_FILE_PATH}"
    export db_file=$DB_FILE_PATH
}

take_source_data_url() {
    
    # input data source url
    SOURCE_DATA=$(if [ "${SOURCE_DATA}" != "" ]; then echo ${SOURCE_DATA}; else prompt_for_explicit_input_with_validation "Enter SOURCE_DATA: " "Provide data source url, press enter to omit" ".*" "please provide valid datasource url"; fi) || exit $?
    if [[ $SOURCE_DATA != "" ]]; then
        status_log $TYPE_DEFAULT "SOURCE_DATA: ${SOURCE_DATA}"
        export testdata_url=$SOURCE_DATA
    else
        yq eval 'del(.grapi.initContainers)' -i $template_file_dest
    fi
}

# ----------------------- functions code ended ---------------------

# ------------------------------------------------------------------

# ---------------- first check for input params --------------------

# valid arguments array
valid_args=(
    "KUBECTL_CONTEXT"
    "GRAS_NAME"
    "GRAS_TEMPLATE"
    "SOURCE_DATA"
    "DB_FILE_PATH"
    "DB_TYPE"
    "ENABLE_GRUIM"
    "MODELS"
    "RELATIONS"
    "KUBE_NS"
    "DATA_SOURCES"
    "DISCOVERIES"
  )

# check if values are already passed form terminal
# if yes? then store then in the respective vars
[ "$1" = "$cli_params" ] && extract_input_params_from_cli $valid_args "grpl r d h" $(echo "$@" | sed 's,help,,' | sed 's,h ,,' | sed 's,--params ,,')

# check if values are already passed form terminal through a file
# if yes? then store then in the respective vars
[ "$1" = "$config_file_params" ] && extract_input_params_from_file $valid_args "grpl r d h" $(echo "$@" | sed 's,help,,' | sed 's,h ,,' | sed 's,--configfile ,,')

#check if input from params is valid or not
is_correct_kubectl_context_provided $KUBECTL_CONTEXT
contexts=$(kubectl config get-contexts -o name)
KUBECTL_CONTEXT=$(if [ "${KUBECTL_CONTEXT}" != "" ]; then echo ${KUBECTL_CONTEXT}; else gum choose  --header "Please select kubectl context you want to use" $contexts ; fi) || exit $?
kubectl config use-context $KUBECTL_CONTEXT
status_log $TYPE_DEFAULT "KUBECTL_CONTEXT: ${KUBECTL_CONTEXT}"


#check if input from params is valid or not
if [ "${GRAS_NAME}" != "" ]; then 
  is_value_correct_wrt_regex $GRAS_NAME $alphaNum_plus_hyphen_and_underscope_regex "gras name can only contain alpha numaric characters, '-'and '_' as special characters"
fi
GRAS_NAME=$(if [ "${GRAS_NAME}" != "" ]; then echo ${GRAS_NAME}; else prompt_for_input_with_validation "Enter GRAS_NAME: " "Provide gras name" "$alphaNum_plus_hyphen_and_underscope_regex" "gras name can only contain alpha numaric characters, '-' and '_' as special characters"; fi) || exit $?
status_log $TYPE_DEFAULT "GRAS_NAME: ${GRAS_NAME}"

#check if input from params is valid or not
if [ "${GRAS_TEMPLATE}" != "" ]; then 
  is_correct_grapple_applicationsets_provided $GRAS_TEMPLATE 
fi
GRAS_TEMPLATE=$(if [ "${GRAS_TEMPLATE}" != "" ]; then echo ${GRAS_TEMPLATE}; else gum choose  --header "Please select template you want create" $DB_FILE $DB_MYSQL $DB_MYSQL_DISCOVERY_BASED $DB_POSTGRES $DB_POSTGRES_DISCOVERY_BASED; fi) || exit $?
status_log $TYPE_DEFAULT "GRAS_TEMPLATE: ${GRAS_TEMPLATE}"


check_and_create_kubens

# ----------------------- params code ended ---------------------------



if [ "$GRAS_TEMPLATE" == "$DB_FILE" ]; then

    template_file_dest="/tmp/db-file.yaml"
    db_file_default_value=/data/db.json
    cp "$GRPL_WORKDIR/template-files/db-file.yaml" $template_file_dest

    # input model
    if [[ $MODELS == "" ]]; then
        take_model_input
    else 
        # the input model should look like this
        # 'customers:{"base":"Entity","name":"customers","properties":{"city":{"type":"string"},"generatedValue":{"generated":true,"defaultFn":999,"id":false,"required":true,"type":"number"}}}|employees:{"base":"Entity","name":"employees","properties":{"country":{"type":"string"},"creditLimit":{"type":"number"}}}'
        transform_model_input_to_yaml $MODELS
    fi 


    take_db_file_path
    take_source_data_url

    cli_args=$@
    if [[ "${cli_args[@]}" =~ "--RELATIONS" ]] && [[ $RELATIONS == "" ]] ; then
        yq eval 'del(.grapi.relations)' -i $template_file_dest
    else
        take_relation_input "${models_name[@]}"
    fi
    

    input_guim_option

    check_and_install_gettext
    envsubst < "$template_file_dest" > "$tmp_file_dest" && mv "$tmp_file_dest" "$template_file_dest"

    # at this point our template manifest is ready at /tmp/db-file.yaml
    # we'll deploy it now
    deploy_template

    # now remove the tmp file
    rm $template_file_dest
    
    exit 1
fi

# for all other cases
template_file_dest="/tmp/db.yaml"
cp "$GRPL_WORKDIR/template-files/db.yaml" $template_file_dest

#check if input from params is valid or not
if [ "${DB_TYPE}" != "" ]; then 
  is_correct_db_type_provided $DB_TYPE 
fi
DB_TYPE=$(if [ "${DB_TYPE}" != "" ]; then echo ${DB_TYPE}; else gum choose  --header "Please select the database type you want" $INTERNAL_DB $EXTERNAL_DB; fi) || exit $?
status_log $TYPE_DEFAULT "DB_TYPE: ${DB_TYPE}"

if [[ $DB_TYPE == "$INTERNAL_DB" ]]; then

    status_log $TYPE_INFO "installing kbcli and kubeblocks"
    check_and_install_kbcli
    check_and_install_kubeblocks

    status_log $TYPE_INFO "waiting for configs to apply"
    for i in $(kubectl get clusterversion -o name); do 
        kubectl get $i -o yaml | sed "s,infracreate-registry.cn-zhangjiakou.cr.aliyuncs.com,docker.io,g" | kubectl apply -f - >/dev/null 2>&1; 
    done

    kubectl apply -n ${KUBE_NS} -f $GRPL_WORKDIR/files/db.yaml
    status_log $TYPE_INFO "created internal db"

elif [[ $DB_TYPE == "$EXTERNAL_DB" ]]; then

    if [[ $DATA_SOURCES != "" ]]; then
        transform_datasources_input_to_yaml $DATA_SOURCES
    else 
        host= prompt_for_input_with_validation "host: " "please provide host: " "$non_empty_regex" "host name can't be empty"
        status_log $TYPE_DEFAULT "host: ${host}"    

        port= prompt_for_input_with_validation "port: " "please provide port: " "$non_empty_regex" "port name can't be empty"
        status_log $TYPE_DEFAULT "port: ${port}"   

        user= prompt_for_input_with_validation "user: " "please provide user: " "$non_empty_regex" "user name can't be empty"
        status_log $TYPE_DEFAULT "user: ${user}"

        read -s -p "Password: " password
        status_log $TYPE_DEFAULT "password: ${password}"

        database= prompt_for_input_with_validation "database: " "please provide database: " "$non_empty_regex" "database name can't be empty"
        status_log $TYPE_DEFAULT "database: ${database}"

        export host=$host
        export port=$port
        export user=$user
        export password=$password
        export database=$database
    fi 

fi

if [[ "$GRAS_TEMPLATE" == "$DB_MYSQL"  ]]; then

    take_source_data_url
    mysql_init_container_bash_script="['bash', '-c', 'sleep 5; while ! mysql -h \$(host) -P \$(port) -u \$(username) -p\$(password) -e \"show databases;\" 2>/dev/null; do echo -n .; sleep 2; done; if mysql -h \$(host) -P \$(port) -u \$(username) -p\$(password) -e \"use classicmodelsid; select * from customers limit 1;\"; then echo \"database already exists...\"; else curl -o /tmp/classicmodelsid.sql $SOURCE_DATA; mysql -h \$(host) -P \$(port) -u \$(username) -p\$(password) < /tmp/classicmodelsid.sql; rm /tmp/classicmodelsid.sql; fi']"
    yq -i ".grapi.initContainers[0].spec.image=\"mysql\"" $template_file_dest
    export command=$mysql_init_container_bash_script

    
fi

if [[ "$GRAS_TEMPLATE" == "$DB_MYSQL_DISCOVERY_BASED"  ]]; then
    if [[ "$DISCOVERIES" != "" ]]; then
        transform_discoveries_input_to_yaml $DISCOVERIES
    fi
fi


take_relation_input
input_guim_option

check_and_install_gettext
envsubst < "$template_file_dest" > "$tmp_file_dest" && mv "$tmp_file_dest" "$template_file_dest"

# at this point our template manifest is ready at /tmp/db.yaml
# we'll deploy it now
deploy_template