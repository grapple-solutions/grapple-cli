#!/bin/bash


# available packages installations
# package names
# helm
# kubectl
# gum="minikube"
# civo
# kbcli
# kubeblocks


check_and_install_snap() {

    # if OS is gnu, we want to check and install snap
    # this package will be used to install other packages in future
    if [ $OS == "gnu" ] && ! snap version >/dev/null 2>&1; then
        echo "snap is a prerequisite package manager to install packages for linux"
        echo "installing snap..."
        sudo apt update
        sudo apt install snapd
        snap --version | grep snapd >> "$GRPL_WORKDIR/dependency_versions"
    fi

}

check_and_install_gum() {

    # checks for checking and installing gum
    if ! gum --version >/dev/null 2>&1; then
            echo "gum is a prerequisite for this script to run."
            echo "installing gum..."
        if [ "${OS}" == "mac" ]; then
            brew install gum
        elif [ "${OS}" == "gnu" ]; then 
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg
            echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | sudo tee /etc/apt/sources.list.d/charm.list
            sudo apt update && sudo apt install gum
            sudo ln -s /usr/bin/gum /snap/bin/gum
        else
            errMsg="Failed to install a prerequisite gum, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

    extract_gum_cli_version

}

check_and_install_helm() {

    # checks for checking and installing helm
    if ! helm >/dev/null 2>&1; then
        echo "helm is a prerequisite for this script to run."
        echo "installing helm..."
        if [ $OS == "mac" ]; then 
            gum spin --title "a prerequisite helm is not installed, now installing helm" --show-output -- brew install helm
        elif [ $OS == "gnu" ]; then
            sudo snap refresh >/dev/null 2>&1
            gum spin --title "a prerequisite helm is not installed, now installing helm" --show-output -- sudo snap install helm --classic
        else
            errMsg="Failed to install a prerequisite helm, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

    extract_helm_cli_version

}

check_and_install_kubectl(){

    # checks for checking and installing kubectl
    if ! kubectl >/dev/null 2>&1; then
        echo "kubectl is a prerequisite for this script to run."
        echo "installing kubectl..."
        if [ $OS == "mac" ]; then 
            gum spin --title "a prerequisite kubectl is not installed, now installing kubectl" --show-output -- brew install kubectl
        elif [ $OS == "gnu" ]; then
            sudo snap refresh >/dev/null 2>&1
            gum spin --title "a prerequisite kubectl is not installed, now installing kubectl" --show-output -- sudo snap install kubectl --classic
        else
            errMsg="Failed to install a prerequisite kubectl, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

}

check_and_install_civo() {

    # checks for checking and installing civo
    if ! civo version 2>&1; then
        echo "civo cli is required"
        echo "installing civo cli..."
        gum spin --title "civo is not installed, now installing civo" --show-output -- curl -sL https://civo.com/get | sh
        status_log $TYPE_INFO "going to move /tmp/civo /usr/local/bin/civo this might take some time"
        sudo mv /tmp/civo /usr/local/bin/civo
    fi
 
    extract_civo_cli_version
}

check_and_install_minikube() {

    # checks for checking and installing minikube
    if ! minikube version 2>&1; then
        echo "minikube cli is required"
        echo "installing minikube cli..."
        if [ "${OS}" == "mac" ]; then
            gum spin --title "minikube is not installed, now installing minikube" --show-output --  brew install minikube
        elif [ "${OS}" == "gnu" ]; then
            gum spin --title "minikube is not installed, now installing minikube" --show-output --  wget https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
            chmod +x minikube-linux-amd64
            sudo mv minikube-linux-amd64 /usr/local/bin/minikube
        else
            errMsg="Failed to install minikube, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

    extract_minikube_cli_version

}

check_and_install_kbcli() {

    # checks for checking and installing kbcli
    if ! kbcli >/dev/null 2>&1; then
        gum spin --title "a prerequisite kbcli is not installed, now installing kbcli" --show-output -- curl -fsSL https://kubeblocks.io/installer/install_cli.sh | bash 
        sleep 2
    fi

    extract_kbcli_cli_version

}

check_and_install_kubeblocks() {

    # checks for checking and installing kubeblocks
    if ! kbcli cluster list 2>/dev/null || ! kbcli kubeblocks status; then
        gum spin --title "installing kubeblocks" --show-output -- kbcli kubeblocks install --set image.registry="docker.io"
    fi
   
    extract_kubeblocks_cli_version
    
}

check_and_install_asciidoc() {

    # checks for checking and installing minikube
    if ! asciidoctor --version  >/dev/null 2>&1; then
        echo "asciidoctor cli is required"
        echo "installing asciidoctor cli..."
        if [ "${OS}" == "mac" ]; then
            gum spin --title "asciidoctor is not installed, now installing asciidoctor" --show-output -- brew install asciidoctor
        elif [ "${OS}" == "gnu" ]; then
            status_log $TYPE_INFO "going to refresh snap"
            sudo snap refresh 2>&1
            gum spin --title "ruby is not installed, now installing ruby" --show-output -- sudo snap install ruby --classic
            gum spin --title "asciidoctor is not installed, now installing asciidoctor" --show-output -- gem install asciidoctor
            exe_file_path=$(gem which asciidoctor)
            extracted_version=$(echo "$string" | awk -F '/' '{print $6}')
            asciidoc_template_path="~/.gem/gems/{}/bin"
            asciidoc_path=$(echo "$asciidoc_template_path" | sed 's/{}/asciidoctor-2.0.22/')
            export PATH="$asciidoc_path:$PATH"
        else
            errMsg="Failed to install asciidoctor, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

}

check_and_install_git() {

    # checks for checking and installing git
    if ! git version  >/dev/null 2>&1; then
        echo "git cli is required"
        echo "installing git cli..."
        if [ "${OS}" == "mac" ]; then
            gum spin --title "git is not installed, now installing git" --show-output -- brew install git
        elif [ "${OS}" == "gnu" ]; then
            status_log $TYPE_INFO "going to update apt"
            sudo apt update 2>&1
            gum spin --title "git is not installed, now installing git" --show-output -- sudo apt install git
        else
            errMsg="Failed to install git, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

    extract_git_cli_version
    
}

check_and_install_jq() {

    # checks for checking and installing jq
    if ! jq --version  >/dev/null 2>&1; then
        echo "jq cli is required"
        echo "installing jq cli..."
        if [ "${OS}" == "mac" ]; then
            gum spin --title "jq is not installed, now installing jq" --show-output -- brew install jq
        elif [ "${OS}" == "gnu" ]; then
            status_log $TYPE_INFO "going to refresh snap"
            sudo snap refresh >/dev/null 2>&1
            gum spin --title "jq is not installed, now installing jq" --show-output -- sudo snap install jq
        else
            errMsg="Failed to install jq, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

    extract_jq_cli_version
    
}

check_and_install_yq() {

    # checks for checking and installing yq
    if ! yq --version  >/dev/null 2>&1; then
        echo "yq cli is required"
        echo "installing yq cli..."
        if [ "${OS}" == "mac" ]; then
            gum spin --title "yq is not installed, now installing yq" --show-output -- brew install yq
        elif [ "${OS}" == "gnu" ]; then
            status_log $TYPE_INFO "going to refresh snap"
            sudo snap refresh >/dev/null 2>&1
            gum spin --title "yq is not installed, now installing yq" --show-output -- sudo snap install yq
        else
            errMsg="Failed to install yq, OS ${OS} not supported at the moment"
            echo $errMsg
            status_log $TYPE_ERROR $errMsg
            exit 1
        fi
    fi

    extract_yq_cli_version
    
}

check_and_install_gettext() {

    if [ "${OS}" != "mac" ]; then
        return 0
    fi
    # checks for checking and installing git
    if ! gettext --version  >/dev/null 2>&1; then
        echo "gettext cli is required"
        echo "installing gettext cli..."
        gum spin --title "gettext is not installed, now installing gettext" --show-output -- brew install gettext
        gum spin --title "linking gettext" --show-output -- brew link --force gettext
    fi
    
}


extract_helm_cli_version(){

    if ! grep -q "helm" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Store the output of 'helm version' in a variable
        helm_output=$(helm version 2>/dev/null)

        # Extract the Helm version number using sed and store it in a variable
        helm_version=$(echo "$helm_output" | sed -n 's/version.BuildInfo{Version:"\([^"]*\).*/\1/p')

        # Output the latest version
        echo "      $helm_version - helm" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}

extract_kubectl_cli_version(){

    if ! grep -q "kubectl" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Store the output of 'kubectl version' in a variable
        kubectl_output=$(kubectl version 2>/dev/null)

        # Extract the client version number using awk and store it in a variable
        kubectl_client_version=$(echo "$kubectl_output" | awk '/Client Version:/{print $NF}')

        # Output the latest version
        echo "      $kubectl_client_version - kubectl" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}

extract_gum_cli_version(){

    if ! grep -q "gum" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Store the output of 'gum -v' in a variable
        gum_output=$(gum -v 2>/dev/null)

        # Extract version number using grep
        gum_version=$(echo "$gum_output" | grep -o '[0-9][0-9.]*')

        # Output the latest version
        echo "      v$gum_version - gum" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}

extract_civo_cli_version(){

    if ! grep -q "civo" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Store the output of civo version in a variable
        civo_output=$(civo version 2>/dev/null)

        # Extract version number using grep and awk
        civo_version=$(echo "$civo_output" | grep -o 'Civo CLI v[0-9.]*' | awk '{print $3}')

        # Output the latest version
        echo "      $civo_version - civo" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}


extract_minikube_cli_version(){

    if ! grep -q "minikube" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Run minikube version command and capture its output
        minikube_output=$(minikube version 2>/dev/null)

        # Extract version number using grep and awk
        minikube_version=$(echo "$minikube_output" | grep -o 'minikube version: v[0-9.]*' | awk '{print $3}')

        # Output the latest version
        echo "      $minikube_version - minikube" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}


extract_kbcli_cli_version(){

    if ! grep -q "kbcli" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Run kbcli version command and capture its output
        kbcli_output=$(kbcli version 2>/dev/null)

        # Extract version number using grep and awk
        kbcli_version=$(echo "$kbcli_output" | grep -o 'kbcli: [0-9.]*' | awk '{print $2}')

        # Output the latest version
        echo "      v$kbcli_version - kbcli" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}

extract_kubeblocks_cli_version(){

    if ! grep -q "kubeblocks" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Run kbcli version command and capture its output
        output=$(kbcli version 2>/dev/null)

        # Extract KubeBlocks version number using grep and awk
        kubeblocks_version=$(echo "$output" | grep -o 'KubeBlocks: [0-9.]*' | awk '{print $2}')

        # Output the latest version
        echo "      v$kubeblocks_version - kubeblocks" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}

extract_grapple_cli_version(){

    if ! grep -q "." "$GRPL_WORKDIR/VERSION" >/dev/null 2>&1; then 

        # Run kbcli version command and capture its output
        output=$(brew info --json grapple-cli)

        # Extract KubeBlocks version number
        grpl_version=$(echo "$output" | grep -o '"version": "[^"]*' | sed 's/"version": "//')

        # Output the latest version
        echo "$grpl_version" > "$GRPL_WORKDIR/VERSION"
    fi

}


extract_git_cli_version(){

    if ! grep -q "git" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Run git version command and store the output
        git_version=$(git version)

        # Extract version number using regular expression
        regex="git version ([0-9]+\.[0-9]+\.[0-9]+)"
        version_number=""
        if [[ $git_version =~ $regex ]]; then
            version_number=${BASH_REMATCH[1]}
            echo "Git version number: $version_number"
        else
            echo "Failed to extract version number from git version output."
            return 0
        fi

        # Output the latest version
        echo "      v$version_number - git" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}

extract_jq_cli_version(){

    if ! grep -q "jq" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Get jq version
        jq_version=$(jq --version | awk -F'[- ]' '{print $2}')

        # Output the latest version
        echo "      v$jq_version - jq" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}



extract_yq_cli_version(){

    if ! grep -q "yq" "$GRPL_WORKDIR/dependency_versions" >/dev/null 2>&1; then 

        # Get yq version
        yq_version=$(yq --version | awk '{print $NF}')

        # Output the latest version
        echo "      $yq_version - yq" >> "$GRPL_WORKDIR/dependency_versions"
    fi

}